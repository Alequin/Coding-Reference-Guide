<!DOCTYPE html>
<html lang="en">

<head>
  <title>Ruby Summary</title>
  <meta charset="utf-8">
  <link href="../css/basic-layout.css" type="text/css" rel="stylesheet"/>
  <link href="../css/summary-page-layout.css" type="text/css" rel="stylesheet"/>
  <link id="summary-page-layout" href="../css/normal-text-summary-page.css" type="text/css" rel="stylesheet"/>
  <link href="../css/ruby.css" type="text/css" rel="stylesheet"/>
</head>

<body>

  <div id="header-container">
    <h1 id="main-header">Helpful Ruby</h1>

    <div id="contents-container">
      <div class="header-divider divider"></div>
      <table id="search-and-sort-table">
        <tr>
          <td>
            <form name="search-form">
              <input id="contents-search-box" class="section-text-normal" type="text" name="search-term"/>
            </form>
          </td>
          <td>
            <p id="search-button" class="section-text-normal">
              <span class="vertical-align-text">Search</span>
            </p>
          </td>
          <td>
            <p id="order-button" class="section-text-normal">
              <span class="vertical-align-text"></span>
            </p>
          </td>
        </tr>
      </table>

    </div>
    <div class="header-divider divider"></div>
  </div>

  <div id="header-space"></div>

  <div id="primary-container">

    <div class="divider"></div>

    <div class="section">

      <div id="directories-files" class="title-anchor"></div>
      <h2 class="section-header">Directories and files</h2>

      <div class="section-content section-text-normal">
        <p>
          Ruby provides a class called Dir which represents the directories /
          file tree of the current computer.
        </p>

        <dl>

          <dt>
            <b>Dir.entries "/"</b><br>
            <b>Dir.entries "/Users/"</b>
          </dt>
          <dd>
            The <b>entries</b> method will provide an array of the files
            and directories contained at the given path (this includes hidden
            files).
          </dd>
          <br>
          <dt>
            <b>Dir["/*"]</b><br>
            <b>Dir["/dir/*"]</b><br>
            <b>Dir["/dir/*.txt"]</b>
          </dt>
          <dd>
            Accessing <b>Dir</b> with <b>[]</b> also returns an array of the
            files and directories contained at the given path. This does not
            return hidden files and requires some form of file name be provided.
            This is used to filter the returned files as in the last example,
            which will only return files that end in '.txt'
          </dd>

        </dl>

        <p>
          (Sources:<br>
          <a href="https://ruby-doc.org/core-2.2.0/Dir.html">
            Ruby Documentation: Dir
          </a>)
        </p>
        <p><em>Updated: 08/05/2017</em></p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="ruby-console-commands" class="title-anchor"></div>
      <h2 class="section-header">Run Console Command With Ruby</h2>

      <div class="section-content section-text-normal">
        <p>
          <strong>
            <u>%x(command)</u>
            <br><br>
            p %x(echo hello)
            <br><br>
            #=> "hello\n"
          </strong>
          <br><br>
          Returns stdout and redirects stderr to calling terminal. Delimeters
          can be any character.
          <br><br>
          <strong>
            <u>system("command")</u>
            <br><br>
            p system("echo hello")
            <br><br>
            #=> hello #echo command result
            # true
          </strong>
          <br><br>
          Returns true if the command was found and run successfully. Redirects
          stderr to calling terminal.
          <br><br>
          <strong>
            <u>spawn("command")</u>
            <br><br>
            p spawn("echo hello")
            <br><br>
            #=> 5875 #number will vary
          </strong>
          <br><br>
          Returns pid
          <a href="https://en.wikipedia.org/wiki/Process_identifier">
            (Process identifier)
          </a> of the command. Redirects stderr
          to calling terminal.
          <br><br>
          <strong>
            <u>IO.popen("command")</u>
            <br><br>
            io = IO.popen("echo hello && echo hello again")
            p io.readlines
            <br><br>
            #=> ["hello\n", "hello again\n"]
          </strong>
          <br><br>
          IO.popen returns an IO opject and runs the given commands as a
          subprocess, with the stdout connected the IO object. Each command stores
          a returned line (if it has a return value), which may be accessed via
          the methods readline (return each value one at a time) or readlines
          (return all values as an array). Each call the either of these
          methods will remove the returned values from been accessed in the same
          way. The PID can be found using the method pid. Redirects stderr to
          calling terminal.
          <br><br>
          <strong>
            <u>Open3.popen3("command")</u>
            <br><br>
            require 'open3'
            <br><br>
            stdin, stdout, stderr = Open3.popen3("echo hello &#38;&#38; ruby not-real.rb")<br>
            p stdout.readlines<br>
            p stderr.readlines
            <br><br>
            #=> ["hello\n"]<br>
            ["ruby: No such file or directory -- not-real.rb (LoadError)\n"]
          </strong>
          <br><br>
          Open3 returns an object which allows access to both returned values
          of stdout and stderr (stderr is not redirected to calling terminal).
          readline and readlines methods are used to access values (same as
          IO.open). Open3 also allows for other obects such as popen2 or capture
          3. For full details view
          <a href="https://docs.ruby-lang.org/en/2.0.0/Open3.html">
            ruby docs: module Open3.
          </a>
          <br><br>

          (Sources:<br>
          <a href="http://stackoverflow.com/questions/3159945/running-command-line-commands-within-ruby-script">
            stackoverflow: Running command line commands within Ruby script
          </a><br>
          <a href="https://gist.github.com/JosephPecoraro/4069">
            GitHub: JosephPecoraro
          </a><br>
          <a href="https://ruby-doc.org/core-2.4.1/Kernel.html#method-i-exec">
            Ruby documentation: Kernal
          </a><br>
          <a href="https://docs.ruby-lang.org/en/2.0.0/Open3.html">
            Ruby documentation: module Open3
          </a><br>
          <a href="http://mentalized.net/journal/2010/03/08/5-ways-to-run-commands-from-ruby/">
            mentalized: 5 ways to run commands from Ruby
          </a>)
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="pipe-chars-and-files" class="title-anchor"></div>
      <h2 class="section-header">Redirection &#38; Pipe Characters</h2>

      <div class="section-content section-text-normal">
        <p>
          Using pipe character allows for the redirection of input and output
          from the terminal.
        </p>

          <p>
            <b>$ ruby ruby-file.rb &#62; io-text-file.txt</b>
          </p>

          <p>
            This will produce, or replace if it already exists, the text file
            output-text-file.txt and fill each line with any values that would
            normally be output to console. The once the script stops running. The
            file is produced once the code begins but the contents are not input
            until the code ends.
          </p>

          <p>
            The opposite may also be done and text files may be used in the place
            of user input.
          </p>

          <p>
            <b>$ ruby ruby-input.rb &#60; input.txt</b><br>
            <a href="../examples/ruby/input.txt">input.txt</a><br>
            <a href="../examples/ruby/ruby-input.rb">ruby-input.rb</a>
          </p>

          <p>
            This will make any methods that normally ask for user input to accept
            a lines from a text file and use that as input. Each call for input
            from the program will result in a new line from the text file
            being used.
          </p>

          <p>
            Another symbol which may be used is the <b>|</b> character.
          </p>

          <p>
            <b>$ ruby ruby-output.rb | ruby ruby-input.rb</b><br>
            <a href="../examples/ruby/ruby-output.rb">ruby-output.rb</a><br>
            <a href="../examples/ruby/ruby-input.rb">ruby-input.rb</a><br>
          </p>

          <p>
            This will take the output of the first command and use it as the
            input of the other. This can be used to take the output of one
            program and be used in another.
          </p>

          <p>These commands may also be chained together</p>

          <p>
            <b>$ ruby ruby-output.rb | ruby ruby-input.rb > output.txt</b><br>
            <a href="../examples/ruby/ruby-output.rb">ruby-output.rb</a><br>
            <a href="../examples/ruby/ruby-input.rb">ruby-input.rb</a><br>
          </p>

          <p>
            (Sources:<br>
            <a href="https://www.thoughtco.com/using-the-command-line-2908368">
              ThoughtCo: Running and Executing rb Files
            </a>)
          </p>
          <p><em>Updated: 07/05/2017</em></p>
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="exception-handling" class="title-anchor"></div>
      <h2 class="section-header">Exception Handling</h2>
      <div class="section-content">
        <p class="section-text-normal">
          Exceptions are raised (as it is known in Ruby) when the code causes an
          error and cannot be processed. This will cause the program to quit
          unless the exception is handled. To handle exception begin and rescue are
          used to create a code block around the code that may produce an error.
          <br><br>
          <strong>
            begin<br>
            &#160;&#160;puts 10/0 #raises a ZeroDivisionError<br>
            &#160;&#160;puts "Math complete"<br>
            rescue<br>
            &#160;&#160;puts "You cannot divide by zero"<br>
            end<br>
            #=> You cannot divide by zero
          </strong>
          <br><br>
          The key word else can be included after rescue, which will run if no
          errors occured.
          <br><br>
          <strong>
            begin<br>
            &#160;&#160;a = 10/1<br>
            &#160;&#160;puts "Math complete"<br>
            rescue<br>
            &#160;&#160;puts "You cannot divide by zero"<br>
            else<br>
            &#160;&#160;puts "Woohoo!"<br>
            end<br>
            #=> Math complete<br>
            # Woohoo!
          </strong>
          <br><br>
          The key word ensure can be included after else. This will always be
          run regardless of whether an error occured.
          <br><br>
          <strong>
            error = false<br>
            begin<br>
            &#160;&#160;a = 10/0<br>
            &#160;&#160;puts "Math complete"<br>
            rescue<br>
            &#160;&#160;error = true<br>
            else<br>
            &#160;&#160;puts "Woohoo!"<br>
            ensure<br>
            &#160;&#160;puts error ? "An error occured" : "No error occured"<br>
            end<br>
            #=> An error occured
          </strong>
          <br><br>
          The key word retry can be used in the rescue block to restart the code
          block from begin.
          <br><br>
          <strong>
            a = 10<br>
            b = 0<br>
            begin<br>
            &#160;&#160;c = a / b<br>
            &#160;&#160;puts "Math complete"<br>
            rescue<br>
            &#160;&#160;puts "You cannot divide by zero"<br>
            &#160;&#160;b = 1<br>
            &#160;&#160;retry<br>
            end<br>
            #=> You cannot divide by zero<br>
            # Math complete
          </strong>
          <br><br>
          Below is an example of it all working together.
          <br><br>
          <strong>
            a = 10<br>
            b = 0<br>
            error = false<br>
            begin<br>
            &#160;&#160;c = a / b<br>
            &#160;&#160;puts "Math complete"<br>
            rescue<br>
            &#160;&#160;puts "You cannot divide by zero"<br>
            &#160;&#160;error = true<br>
            &#160;&#160;b = 1<br>
            &#160;&#160;retry<br>
            else<br>
            &#160;&#160;puts "Woohoo!"<br>
            ensure<br>
            &#160;&#160;puts error ? "An error occured" : "No error occured"<br>
            end<br>
            #=> You cannot divide by zero<br>
            # Math complete<br>
            # Woohoo!<br>
            # An error occured
          </strong>
          <br><br>
          It is possible to provide multiple rescue blocks and provide each with
          a specific exception. This enables different code to be executed based
          on the exception raised.
          <br><br>
          <strong>
            begin<br>
            &#160;&#160;a = 10<br>
            &#160;&#160;b = "20"<br>
            &#160;&#160;puts a + b<br>
            rescue ZeroDivisionError<br>
            &#160;&#160;puts "You cannot divide by zero"<br>
            rescue TypeError<br>
            &#160;&#160;puts "You cannot add a #{a.class} and a #{b.class}"<br>
            end<br>
            #=> You cannot add a Fixnum and a String
          </strong>
          <br><br>
          It is also possible to get the exception as a variable from rescue and
          manage code by making use of it.
          <br><br>
          <strong>
            begin<br>
            &#160;&#160;a = 10<br>
            &#160;&#160;b = "20"<br>
            &#160;&#160;puts a + b<br>
            rescue => e<br>
            &#160;&#160;case (e.class).to_s<br>
            &#160;&#160;when "ZeroDivisionError"<br>
            &#160;&#160;&#160;&#160;puts "You cannot divide by zero"<br>
            &#160;&#160;when "TypeError"<br>
            &#160;&#160;&#160;&#160;puts "You cannot add a #{a.class} and a #{b.class}"<br>
            &#160;&#160;else<br>
            &#160;&#160;&#160;&#160;puts "#{(e.class).to_s} raised"<br>
            &#160;&#160;end<br>
            end<br>
            #=> You cannot add a Fixnum and a String
          </strong>
          <br><br>
            While writing code there may be a number of situation you consider
            erroneous but do not actually raise an exception. In these cases it
            is possible to define when an exception should be raised.
          <br><br>
          <strong>
            def feed_dog(amount)<br>
            &#160;&#160;if(amount &#60; 0)<br>
            &#160;&#160;&#160;&#160;raise ArgumentError, "A positive value is needed"<br>
            &#160;&#160;end<br>
            &#160;&#160;puts "The dog is happy but wants more"<br>
            end
            <br><br>
            feed_dog(2)<br>
            feed_dog(-1)<br>
            #=> The dog is happy but wants more<br>
            # A positive value is needed (ArgumentError)
          </strong>
          <br><br>
            There are a number of pre-defined exception provided by ruby. It is
            also possible to make custom exceptions by extending any of the
            pre-defined ones.
          <br><br>
          <strong>
            class AngryDogError &#60; ArgumentError<br>
            end
            <br><br>
            def feed_dog(amount)<br>
            &#160;&#160;if(amount &#60; 0)<br>
            &#160;&#160;&#160;&#160;raise AngryDogError, "A positive value is needed"<br>
            &#160;&#160;end<br>
            &#160;&#160;puts "The dog is happy but wants more"<br>
            end
            <br><br>
            feed_dog(-1)<br>
            #=> A positive value is needed (AngryDogError)
          </strong>
          <br><br>
          Below is a list of the Exceptions in ruby and their inheritance
          hierachy.
        </p>

        <div class="img-span">
          <img src="../examples/exception_list.jpg" alt="Ruby exceptions from the Programming Ruby book." />
          <p>
            Image originally from: The Programming Ruby book.<br>
            <a href="https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/overview-of-merge-sort">
            Image taken from: RubyLearning.com: Ruby Exceptions
          </a></p>
        </div>

        <p class="section-text-normal">
          (Sources:<br>
           Beginning Ruby: From Novice to Professional)<br>
          <a href="http://rubylearning.com/satishtalim/ruby_exceptions.html">
            RubyLearning.com: Ruby Exceptions
          </a><br>
          <a href="http://ruby.bastardsbook.com/chapters/exception-handling/">
            The Bastards Book of Ruby: Exception and Error Handling
          </a>)
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="file-inclusion" class="title-anchor"></div>
      <h2 class="section-header">File Inclusion</h2>

      <div class="section-content">
        <p class="section-text-normal">
          In order to pass code between different script files three methods
          are avaliable.
          <br><br>
          <strong>
            require_relative<br>
            load<br>
            require
          </strong>
          <br><br>
          Require relative is used to access the code of files within the same
          directory.
          <br><br>
          <strong>
            File location: ../my_pc/more_ruby.rb<br>
            <br>
            def print<br>
            &#160;&#160;puts "Hello"<br>
            end
            <br><br>
            File location: ../my_pc/ruby.rb
            <br><br>
            require_relative 'more_ruby'<br>
            print<br>
            #=> Hello
          </strong>
          <br><br>
          Load workes in a very similar way to require relative. The script file
          it names must be located in the same directory however load can be
          called on the same file multiple times whereas require_relative can
          only call the same file once. The second time would have no effect.
          Also the file type suffix must be given when using load.
          <br><br>
          <strong>
            File location: ../my_pc/more_ruby.rb<br>
            <br>
            puts "Hello"
            <br><br>
            File location: ../my_pc/ruby.rb
            <br><br>
            puts "First require_relative"<br>
            require_relative 'more_ruby'<br>
            require_relative 'more_ruby'<br>
            require_relative 'more_ruby'
            <br><br>
            puts "Now for load"<br>
            load 'more_ruby.rb'<br>
            load 'more_ruby.rb'<br>
            load 'more_ruby.rb'
            <br><br>
            #=> First require_relative<br>
            # Hello<br>
            # Now for load<br>
            # Hello<br>
            # Hello<br>
            # Hello
          </strong>
          <br><br>
          Require relative and load both work from the current directory and can
          by guided from that location to other files.
          <br><br>
          <strong>
            File location: ../more_ruby.rb<br>
            <br>
            puts "Hello"
            <br><br>
            File location: ../my_pc/user/documents/even_more_ruby.rb<br>
            <br>
            puts "Hello again"
            <br><br>
            File location: ../my_pc/ruby.rb
            <br><br>
            require_relative '../more_ruby'<br>
            load '../more_ruby.rb'<br>
            require_relative 'user/documents/even_more_ruby'<br>
            load 'user/documents/even_more_ruby.rb'
            <br><br>
            #=> Hello<br>
            # Hello<br>
            # Hello<br>
            # Hello
          </strong>
          <br><br>
          The method requrire does not work from the current directory
          (unless instructed to) and instead searches through a number of
          previously defined file locations in which Ruby stores its own files
          and standard libraries.
          <br><br>
          The following is how to instruct require to search the current directory.
          <br><br>
          <strong>
            File location: ../my_pc/more_ruby.rb<br>
            <br>
            def print<br>
            &#160;&#160;puts "Hello"<br>
            end
            <br><br>
            File location: ../my_pc/ruby.rb
            <br><br>
            require './more_ruby'<br>
            print<br>
            #=> Hello
          </strong>
          <br><br>
          The default directories that are searched by the method require can be
          seen by viewing the special variable $: ($LOAD_PATH also works). This
          holds an array and can be viewed.
          <br><br>
          <strong>
            # Outputs may vary<br>
            $:.each { |a| puts a }
            <br><br>
            #=> /home/your_pc/.rvm/gems/ruby-2.3.3@global/gems/did_you_mean-1.0.0/lib<br>
            # /home/your_pc/.rvm/rubies/ruby-2.3.3/lib/ruby/site_ruby/2.3.0<br>
            # /home/your_pc/.rvm/rubies/ruby-2.3.3/lib/ruby/site_ruby/2.3.0/x86_64-linux<br>
            # /home/your_pc/.rvm/rubies/ruby-2.3.3/lib/ruby/site_ruby<br>
            # /home/your_pc/.rvm/rubies/ruby-2.3.3/lib/ruby/vendor_ruby/2.3.0<br>
            # /home/your_pc/.rvm/rubies/ruby-2.3.3/lib/ruby/vendor_ruby/2.3.0/x86_64-linux<br>
            # /home/your_pc/.rvm/rubies/ruby-2.3.3/lib/ruby/vendor_ruby<br>
            # /home/your_pc/.rvm/rubies/ruby-2.3.3/lib/ruby/2.3.0<br>
            # /home/your_pc/.rvm/rubies/ruby-2.3.3/lib/ruby/2.3.0/x86_64-linux
          </strong>
          <br><br>
          Using the push or unshift methods new file locations can be added
          to this array in order to give require method access to custom
          directories.
          <br><br>
          <strong>
            # Outputs may vary<br>
            File location: ../my_pc/more_ruby.rb<br>
            <br>
            def print<br>
            &#160;&#160;puts "Hello"<br>
            end
            <br><br>
            File location: ../my_pc/ruby.rb<br>

            $LOAD_PATH.unshift('../my_pc')<br>
            require 'more_ruby'
            <br><br>
            #=> ../my_pc<br>
            # ..other files ommited.. <br>
            # Hello
            <br><br>
            Note: In this example the symbol ../ is used to in place of a real
            file list but in order for this to work a full directory path should
            be given to the variable $LOAD_PATH.
          </strong>
          <br><br>
          File inclusion can be nested. If the file that is been included already
          includes another file both files will be included in the inital file
          <br><br>
          <strong>
            File location: ../my_pc/layer1.rb<br>
            puts "Hello"<br>
            File location: ../my_pc/layer2.rb<br>
            require_relative 'layer1'<br>
            File location: ../my_pc/layer3.rb<br>
            require_relative 'layer2'<br>
            File location: ../my_pc/ruby.rb<br>
            require_relative 'layer3'<br>
            #=> Hello
          </strong>
          <br><br>
          (Sources:<br>
           Beginning Ruby: From Novice to Professional)
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="comparable-module" class="title-anchor"></div>
      <h2 class="section-header">Comparable Module</h2>

      <div class="section-content">
        <p class="section-text-normal">
          The comparable module can be used add comparison operators to your
          code.
          <br><br>
          <strong>
            class Vehicle<br>
            &#160;&#160;include Comparable
            <br><br>
            &#160;&#160;attr_reader :wheels
            <br><br>
            &#160;&#160;def initialize(wheels)<br>
            &#160;&#160;&#160;&#160;@wheels = wheels<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def &#60;=&#62;(to_compare)<br>
            &#160;&#160;&#160;&#160;@wheels &#60;=&#62; to_compare.wheels<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            bike = Vehicle.new(2)<br>
            car = Vehicle.new(4)<br>
            puts bike &#60; car<br>
            puts car &#62; bike<br>
            puts bike == car<br>
            #=> true<br>
            # true<br>
            # false
          </strong>
          <br><br>
          (Sources:<br>
           Beginning Ruby: From Novice to Professional)
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="structs" class="title-anchor"></div>
      <h2 class="section-header">Structs: Quick Classes</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Struct is a class that quickly creates very simple classes and
          defines variables associated with that class. The struct will also
          apply att_accessor to all variables defined.<br>
          Note: variables associated with structs do not have to be constants.
          <br><br>
          <strong>
            Person = Struct.new(:name, :age)<br>
            lucy = Person.new("Lucy", 23)<br>
            alan = Person.new("Alan", 37)
            <br><br>
            puts "#{lucy.name} - age #{lucy.age}"<br>
            puts "#{alan.name} - age #{alan.age}"
            <br><br>
            lucy.name = "Lucy Smith"<br>
            puts lucy.name
            <br><br>
            #=> Lucy - age 23<br>
            # Alan - age 37<br>
            # Lucy Smith
          </strong>
          <br><br>
          Struct can also define methods if a code block is provided.
          <br><br>
          <strong>
            Person = Struct.new(:name, :age) do<br>
            &#160;&#160;def print_details<br>
            &#160;&#160;&#160;&#160;puts "#{name}, #{age}"<br>
            &#160;&#160;end<br>
            end
            <br><br>
            lucy = Person.new("Lucy", 23)<br>
            alan = Person.new("Alan", 37)
            <br><br>
            lucy.print_details<br>
            alan.print_details
            <br><br>
            #=> Lucy - age 23<br>
            # Alan - age 37
          </strong>
          <br><br>
          When calling a constructor from a class made by a struct not all
          variables have to be defined. The variables which are not given a
          parameter on construction are set to nil and attr_accessor still
          generates methods releated to them.
          <br><br>
          <strong>
            Person = Struct.new(:name, :age)<br>
            lucy = Person.new("Lucy")
            <br><br>
            puts "#{lucy.name} - age #{lucy.age}"
            <br><br>
            lucy.age = 23<br>
            puts lucy.age
            <br><br>
            #=> Lucy - age<br>
            # 23
          </strong>
          <br><br>
          Classes created using structs can be superclasses, allowing thier
          variables to be inherited by the subclass.
          <br><br>
          <strong>
            Person = Struct.new(:name, :age)
            <br><br>
            class Alan &#60; Person<br>
            end
            <br><br>
            baby_alan = Alan.new("Alan", 0.1)<br>
            puts "#{baby_alan.name} - age #{baby_alan.age}"
            <br><br>
            #=> Alan - age 0.1
            <br><br>
            Short method:<br>
            class Alan &#60; Struct.new(:name, :age)<br>
            end
          </strong>
          <br><br>
          As well as structs there are open structs. These work like structs
          but variables can be added after initialization of the open struct.<br>
          Note: Open stucts cannot act as superclasses.
          <br><br>
          <strong>
            # Require must be called to access open structs<br>
            require 'ostruct'
            <br><br>
            Person = OpenStruct.new<br>
            Person.name = "Sandra"<br>
            Person.age = "20"<br>
            Person.height = "160 cm"
            <br><br>
            puts "#{Person.name}, #{Person.age}, #{Person.height}"<br>
            #=> Sandra, 20, 160 cm
          </strong>
          <br><br>
          (Sources:<br>
           Beginning Ruby: From Novice to Professional<br>
          <a href="http://blog.steveklabnik.com/posts/2012-09-01-random-ruby-tricks--struct-new">
          Random Ruby Tricks: Struct.new</a><br>
          <a href="http://blog.logicalbricks.com/node/235">
          Struct and OpenStruct in Ruby</a>)
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="modules" class="title-anchor"></div>
      <h2 class="section-header">Modules</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Modules are collections of methods and constants. Methods can
          either be instance methods or module methods. Module methods are
          defined and called by naming the module and then the method
          (module_name.method_name()). Instance methods are defined
          using only the method name and called by the by an instance
          of a class the related module is included in.
          <br><br>
          <strong>
            module BasicMath
            <br><br>
            &#160;&#160;def BasicMath.add(val1, val2)<br>
            &#160;&#160;&#160;&#160;return val1 + val2<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def subtract(other_val)<br>
            &#160;&#160;&#160;&#160;return self - other_val<br>
            &#160;&#160;end
            <br><br>
            end
          </strong>
          <br><br>
          Using this module we can call the module method from the module...
          <br><br>
          <strong>
            puts BasicMath.add(3,6)<br>
            #=> 9
          </strong>
          <br><br>
          or include the module in a class and use an instance of that class
          to call the instance method (this is the mixin facility).
          <br><br>
          <strong>
            class Fixnum<br>
            &#160;&#160;include BasicMath<br>
            end
            <br><br>
            puts 5.subtract(4)
            #=> 1
          </strong>
          <br><br>
          Another option is to use the extend key word in place of the include
          key word. This gives the class access to the instance methods rather
          than only instances of that class having access.
          <br><br>
          <strong>
            module PrintMod
            <br><br>
            &#160;&#160;def print_hello<br>
            &#160;&#160;&#160;&#160;puts "hello"<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            class IncludeClass<br>
            &#160;&#160;include PrintMod<br>
            end
            <br><br>
            class ExtendClass<br>
            &#160;&#160;extend PrintMod<br>
            end
            <br><br>
            IncludeClass.new.print_hello<br>
            ExtendClass.print_hello
            <br><br>
            #=> hello<br>
            # hello
          </strong>
          <br><br>
          Extend may also be used on already initialised objects to provide
          that instance alone access to the modules methods. (using the
          keyword include in the place of extends in this example would
          produced an undefined method error)
          <br><br>
          <strong>
            module PrintMod
            <br><br>
            &#160;&#160;def print_hello<br>
            &#160;&#160;&#160;&#160;puts "hello"<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            class PostExtendClass; end
            <br><br>
            test = PostExtendClass.new<br>
            test.extend(PrintMod)<br>
            test.print_hello
            <br><br>
            #=> hello
            <br><br>
          </strong>
          Using module methods allows for the definition of methods with the
          same name (using multiple modules) without causing issues. This is
          known as namespacing.
          <br><br>
          <strong>
            module Mod1
            <br><br>
            &#160;&#160;def Mod1.name<br>
            &#160;&#160;&#160;&#160;return "mod1 here"<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            module Mod2
            <br><br>
            &#160;&#160;def Mod2.name<br>
            &#160;&#160;&#160;&#160;return "mod2 here"<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            puts Mod1.name<br>
            puts Mod2.name<br>
            #=> mod1 here<br>
            # mod2 here
          </strong>
          <br><br>
          (Sources:
          <br>
          <a href="http://ruby-doc.com/docs/ProgrammingRuby/html/tut_modules.html">
            ruby-doc: Modules
          </a>
          <br>
          <a href="http://stackoverflow.com/questions/156362/what-is-the-difference-between-include-and-extend-in-ruby">
            stackoverflow: What is the difference between include and extend in Ruby?
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="inheritance" class="title-anchor"></div>
      <h2 class="section-header">Inheritance</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Inheritance is an object oriented idea in which classes can
          inherit variables and methods from other classes. This aids
          programmers to maintain DRY code. Classes that
          inherit from others should follow the is-a principle.
          <br><br>
          Dog is-a Mammal
          <br><br>
          Class Dog could inherit from class Mammal as a dog is a mammal
          but a mammal is not a dog and so could not inherit from dog.
          <br><br>
          In this case the Mammal class is a super class (or parent)
          of the Dog class and the Dog class is a subclass (or child) of
          the Mammal Class.
            <br><br>
          <strong>
            class Mammal
            <br><br>
            &#160;&#160;attr_reader :name
            <br><br>
            &#160;&#160;def initialize(name)<br>
            &#160;&#160;&#160;&#160;@name = name<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def breath<br>
            &#160;&#160;&#160;&#160;return "inhale"<br>
            &#160;&#160;end<br>
            end
            <br><br>
            class Dog &#60; Mammal<br>
              &#160;&#160;def bark<br>
              &#160;&#160;&#160;&#160;return "woof"<br>
              &#160;&#160;end<br>
            end
            <br><br>
            x = Dog.new("Spike")<br>
            puts x.name<br>
            puts x.breath<br>
            puts x.bark<br>
            #=> Spike<br>
            # inhale<br>
            # woof
          </strong>
          <br><br>
          The previous example shows the syntax of inheritance and the use
          of methods defined by the superclass. The methods of the parent
          class are always inherited by the child class but the child class
          is able to override these methods if different functionality is
          desired. This is done by defining a method in the child class
          using the same method name as is used in the super class.
          <br><br>
          <strong>
            class Mammal
            <br><br>
            &#160;&#160;attr_reader :name
            <br><br>
            &#160;&#160;def initialize(name)<br>
            &#160;&#160;&#160;&#160;@name = name<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def breath<br>
            &#160;&#160;&#160;&#160;return "inhale"<br>
            &#160;&#160;end<br>
            end
            <br><br>
            class Dog &#60; Mammal<br>
            &#160;&#160;def bark<br>
            &#160;&#160;&#160;&#160;return "woof"<br>
            &#160;&#160;end<br>
            end
            <br><br>
            class Chihuahua &#60; Dog<br>
            &#160;&#160;def bark<br>
            &#160;&#160;&#160;&#160;return "yap yap"<br>
            &#160;&#160;end<br>
            end
            <br><br>
            x = Chihuahua.new("Spike")<br>
            puts x.name<br>
            puts x.breath<br>
            puts x.bark<br>
            #=> Spike<br>
            # inhale<br>
            # yap yap
          </strong>
          <br><br>
          If a method has been overriden but the functionality from the super
          classe is still required the key word super can be used
          to call the method from the superclass.
          <br><br>
          <strong>
            class Mammal
            <br><br>
            &#160;&#160;attr_reader :name
            <br><br>
            &#160;&#160;def initialize(name)<br>
            &#160;&#160;&#160;&#160;@name = name<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def breath<br>
            &#160;&#160;&#160;&#160;return "inhale"<br>
            &#160;&#160;end<br>
            end
            <br><br>
            class Dog &#60; Mammal<br>
              &#160;&#160;def bark<br>
              &#160;&#160;&#160;&#160;return "woof"<br>
              &#160;&#160;end<br>
            end
            <br><br>
            class GreatDane &#60; Dog<br>
              &#160;&#160;def bark<br>
              &#160;&#160;&#160;&#160;return "#{super.upcase}!!"<br>
              &#160;&#160;end<br>
            end
            <br><br>
            x = GreatDane.new("Spike")<br>
            puts x.name<br>
            puts x.breath<br>
            puts x.bark<br>
            #=> Spike<br>
            # inhale<br>
            # WOOF!!
          </strong>
          <br><br>
          The method initialize can also be overriden and make use of the
          super key word.
          <br><br>
          <strong>
            class Mammal
            <br><br>
            &#160;&#160;attr_reader :name
            <br><br>
            &#160;&#160;def initialize(name)<br>
            &#160;&#160;&#160;&#160;@name = name<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def breath<br>
            &#160;&#160;&#160;&#160;return "inhale"<br>
            &#160;&#160;end<br>
            end
            <br><br>
            class Dog &#60; Mammal
            <br><br>
            &#160;&#160;attr_reader :number_of_legs
            <br><br>
            &#160;&#160;def initialize(name)<br>
            &#160;&#160;&#160;&#160;super(name)<br>
            &#160;&#160;&#160;&#160;@number_of_legs = 4<br>
            &#160;&#160;end
            <br><br>
              &#160;&#160;def bark<br>
              &#160;&#160;&#160;&#160;return "woof"<br>
              &#160;&#160;end<br>
            end
            <br><br>
            x = Dog.new("Spike")<br>
            puts x.name<br>
            puts x.number_of_legs<br>
            puts x.breath<br>
            puts x.bark<br>
            #=> Spike<br>
            # 4<br>
            # inhale<br>
            # woof
          </strong>
          <br><br>
          Classes have different levels of access for methods, public,
          private and protected. Protected methods
          are inherited by child classes the same way public methods are
          but they are not usable by instances of that class. They may only
          be called from within the class.<br>
          For details on public and private methods and different ways to
          assign levels of access view the <a href="#classes">Classes section</a>)
          <br><br>
          <strong>
            class Mammal
            <br><br>
            &#160;&#160;attr_reader :name, :hair_length
            <br><br>
            &#160;&#160;def initialize(name)<br>
            &#160;&#160;&#160;&#160;@name = name<br>
            &#160;&#160;&#160;&#160;@hair_length = 0<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def breath<br>
            &#160;&#160;&#160;&#160;return "inhale"<br>
            &#160;&#160;end
            <br><br>
            protected
            <br><br>
            &#160;&#160;def grow_hair(amount_to_add)<br>
            &#160;&#160;&#160;&#160;@hair_length += amount_to_add<br>
            &#160;&#160;end<br>
            end
            <br><br>
            class Dog &#60; Mammal
            <br><br>
            &#160;&#160;attr_reader :number_of_legs
            <br><br>
            &#160;&#160;def initialize(name)<br>
            &#160;&#160;&#160;&#160;super(name)<br>
            &#160;&#160;&#160;&#160;@number_of_legs = 4<br>
            &#160;&#160;&#160;&#160;grow_hair(20)<br>
            &#160;&#160;end<br>
            end
            <br><br>
            x = Dog.new("Spike")<br>
            puts x.hair_length<br>
            x.grow_hair<br>
            #=> 20<br>
            # (NoMethodError)
          </strong>
          <br><br>
          (Sources:
           Beginning Ruby: From Novice to Professional
          <br>
          <a href="https://www.codecademy.com/learn/ruby">
            codecademy: Object-Oriented Programming, Part I / Object-Oriented Programming, Part II
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="classes" class="title-anchor"></div>
      <h2 class="section-header">Classes</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Classes are an important feature relating to object oriented
          programming as they act as they act as inital blueprints for all
          objects, defining their base state and values. The basic syntax of
          a class in Ruby is shown below. The first letter of a class name
          should always be capitalised.
          <br><br>
          <strong>
            class MyClass<br>
            end
          </strong>
          <br><br>
          Methods are defined using the key word def. Methods can either be
          instance methods (as seen in the previous example) or class methods.
          Instance methods are only avalible after an instance of the class
          has been made. Class methods are avalible without an instance of
          the class and are defined and called by stating the class name and
          then the method name (MyClass.my_method).
          <br><br>
          <strong>
            class MyClass
            <br><br>
            &#160;&#160;def print_hello<br>
            &#160;&#160;&#160;&#160;puts "Hello"<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def MyClass.print_hello1<br>
            &#160;&#160;&#160;&#160;puts "Hello 1"<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            x = MyClass.new<br>
            x.print_hello<br>
            x.print_hello1<br>
            #=> Hello<br>
            #Hello 1
          </strong>
          <br><br>
          Classes can have both public and private methods. This idea is known
          as encapsulation and is used to ensure only the required methods
          are accesible from an object. Private methods can only be used from
          within the class.<br>
          For details on protected methods view the
          <a href="#inheritance">Inheritance section</a>
          <br><br>
          <strong>
            class MyClass
            <br><br>
            &#160;&#160;def print_hello<br>
            &#160;&#160;&#160;&#160;puts "#{get_hello} #{get_number}"<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;private
            <br><br>
            &#160;&#160;def get_hello<br>
            &#160;&#160;&#160;&#160;return "Hello"<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def get_number<br>
            &#160;&#160;&#160;&#160;return 2<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            x = MyClass.new<br>
            x.print_hello<br>
            puts x.get_hello<br>
            #=> Hello 2<br>
            # (NoMethodError)
          </strong>
          <br><br>
          The word private is a method and can be used in multiple ways. Public
          is also a useable method and can be used in the same way as private,
          though all methods not specifically named as private are public.
          <br><br>
          <strong>
            class MyClass
            <br><br>
            &#160;&#160;def print_hello<br>
            &#160;&#160;&#160;&#160;puts "#{get_hello} #{get_number}"<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def get_hello<br>
            &#160;&#160;&#160;&#160;return "Hello"<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def get_number<br>
            &#160;&#160;&#160;&#160;return 2<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;public :print_hello<br>
            &#160;&#160;private :get_hello, :get_number
            <br><br>
            end
            <br><br>
            x = MyClass.new<br>
            x.print_hello<br>
            puts x.get_hello<br>
            #=> Hello 2<br>
            # (NoMethodError)
          </strong>
          <br><br>
          Classes can have three different types of variables associated
          with them, instance, class and global. These variables can be
          created inside or outside of methods within the class and are
          created using the following syntax. <br>
          (Variables without any of these
          prefixes are known as local variables and are only accessible from
          within the method that creates them)
          <br><br>
          <strong>
            Instance: @instance_variable<br>
            Class: @@class_variable<br>
            Global: $global_variable
          </strong>
          <br><br>
          Instance variables are unique to each instance of the class.
          Each time the class is instantiated a new set of variables are
          created for that object. They are defined by using the @ symbol
          prior to the variable name. Once defined they are available to all
          methods.
          <br><br>
          <strong>
            class MyClass
            <br><br>
            &#160;&#160;def set_printer(text)<br>
            &#160;&#160;&#160;&#160;@text = text<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def print_text<br>
            &#160;&#160;&#160;&#160;puts @text<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            x = MyClass.new<br>
            x.set_printer("Hello 3")<br>
            x.print_text
            <br><br>
            y = MyClass.new<br>
            y.set_printer("Hello 4")<br>
            y.print_text
            <br><br>
            #=> Hello 3<br>
            # Hello 4
          </strong>
          <br><br>
          Class variables belong to the class. They are defined using @@ and
          once defined any object created by the class has access to the
          same variable. Only one is every created regardless of how many
          times a new object is created.
          <br><br>
          <strong>
          class MyClass
          <br><br>
            @@times_printed_text = 0
            <br><br>
            &#160;&#160;def set_printer(text)<br>
            &#160;&#160;&#160;&#160;@text = text<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def print_text<br>
            &#160;&#160;&#160;&#160;puts @text<br>
            &#160;&#160;&#160;&#160;@@times_printed_text += 1<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def print_times<br>
            &#160;&#160;&#160;&#160;puts @@times_printed_text<br>
            &#160;&#160;end
            <br><br>
          end
          <br><br>
          x = MyClass.new<br>
          y = MyClass.new<br>
          x.set_printer("Hello 5)<br>
          y.set_printer("Hello 6")
          <br><br>
          x.print_text<br>
          x.print_times<br>
          y.print_text<br>
          y.print_times
          <br><br>
          #=> Hello 5<br>
          # 1<br>
          # Hello 6<br>
          # 2
          </strong>
          <br><br>
          Global variables are avaliable outside the class without the need
          for an instantiated object.
          <br><br>
          <strong>
            class MyClass<br>
            &#160;&#160;$global = "hello 7"<br>
            end
            <br><br>
            puts $global
            <br>
            #=> Hello 7
          </strong>
          <br><br>
          Variables state can be set on object instantiation by using the
          method initialize. If this method is defined within a class it will
          be called each time a new object is created.
          <br><br>
          <strong>
            class MyClass
            <br><br>
            &#160;&#160;def initialize(text)<br>
            &#160;&#160;&#160;&#160;@text = text<br>
            &#160;&#160;end
            <br><br>
            &#160;&#160;def print_text<br>
            &#160;&#160;&#160;&#160;puts @text<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            x = MyClass.new("Hello 8")<br>
            x.print_text
            <br><br>
            y = MyClass.new("Hello 9")<br>
            y.print_text
            <br><br>
            #=> Hello 8<br>
            # Hello 9
          </strong>
          <br><br>
          The previous examples have used custom methods to get and set
          variables but Ruby provides three helpful methods (att_reader,
          attr_writer and att_accessor) to auto generate getter and setter methods.
          <br><br>
          The following example only shows <b>attr_accessor</b> but <b>attr_reader</b>
          (which generates a getter method) and <b>attr_writer</b> (which generates
          a setter method) work in the same way except for the fact that
          <b>attr_accessor</b> provides access to both a getter and a setter.
          <br><br>
          <strong>
            class MyClass
            <br><br>
            attr_accessor :text, :word
            <br><br>
            &#160;&#160;def initialize(text, word)<br>
            &#160;&#160;&#160;&#160;@text = text<br>
            &#160;&#160;&#160;&#160;@word = word<br>
            &#160;&#160;end
            <br><br>
            end
            <br><br>
            x = MyClass.new("Hello 10", "bacon")<br>
            puts x.text <br>
            # setter method<br>
            x.text = "Hello 11"<br>
            # getter method<br>
            puts x.text<br>
            #=> Hello 10<br>
            # Hello 11
          </strong>
          <br><br>
          (Sources:
           Beginning Ruby: From Novice to Professional
          <br>
          <a href="https://github.com/bbatsov/ruby-style-guide#naming">
            The Ruby Style Guide
          </a>
          <br>
          <a href="https://www.codecademy.com/learn/ruby">
            codecademy: Object-Oriented Programming, Part I / Object-Oriented Programming, Part II
          </a>
          <br>
          <a href="http://www.stackoverflow.com/questions/4370960/what-is-attr-accessor-in-ruby">
            stack overflow: What is attr_accessor in Ruby?
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="procs-lambda" class="title-anchor"></div>
      <h2 class="section-header">Procs &#38; Lambdas</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Procs are blocks in the form of a reusable object.
          <br><br>
          <strong>
            var = Proc.new { |a| a += 1 }<br>
            p [1,2,3].collect(&var)<br>
            p (50..53).collect(&var)<br>
            #=> [2,3,4]<br>
            # [51,52,53,54]
            <br><br>
            var = Proc.new { |num| num == 2 }<br>
            def block_test(&code_block)<br>
            &#160;&#160;[1,2,3].select(&code_block)<br>
            end<br>
            p block_test(&var)<br>
            #=> [2]
            <br><br>
            var = Proc.new { |num| num == 2 }<br>
            def block_test(&code_block)<br>
            &#160;&#160;[1,2,3].select() { |a| code_block.call(a) } <br>
            end<br>
            p block_test(&var)<br>
            #=> [2]
          </strong>
          <br><br>
          Lambdas are very similar to procs in that they hold blocks. They do have
          a slightly different syntax.
          <br><br>
          <strong>
            var = lambda { |a| a += 1 }<br>
            p [1,2,3].collect(&var)<br>
            p (50..53).collect(&var)<br>
            #=> [2,3,4]<br>
            # [51,52,53,54]
            <br><br>
            var = lambda { |num| num == 2 }<br>
            def block_test(&code_block)<br>
            &#160;&#160;[1,2,3].select(&code_block)<br>
            end<br>
            p block_test(&var)<br>
            #=> [2]
            <br><br>
            var = lambda { |num| num == 2 }<br>
            def block_test(&code_block)<br>
            &#160;&#160;[1,2,3].select() { |a| code_block.call(a) } <br>
            end<br>
            p block_test(&var)<br>
            #=> [2]
          </strong>
          <br><br>
          Procs and lambdas do have some distinct differences however. For example
          when a Proc block calls return this acts as the methods call to return. The
          value is returned and the method stops processing. Return calls in Lambdas
          allow the method to continue processes after running. This is only true when
          return is explicitly called. As the third example below shows
          <br><br>
          <strong>
            def test_proc<br>
            &#160;&#160;var = Proc.new {return "return from proc"}<br>
            &#160;&#160;var.call<br>
            &#160;&#160;return "return from method"<br>
            end<br>
            puts test_proc<br>
            #=> "return from proc"
            <br><br>
            def test_lambda<br>
            &#160;&#160;var = lambda {return "return from lambda"}<br>
            &#160;&#160;var.call<br>
            &#160;&#160;return "return from method"<br>
            end<br>
            puts test_lambda<br>
            #=> "return from method"
            <br><br>
            def test_proc<br>
            &#160;&#160;var = Proc.new {"return from proc"}<br>
            &#160;&#160;x = var.call<br>
            &#160;&#160;puts x<br>
            &#160;&#160;"return from method"<br>
            end<br>
            puts test_proc<br>
            #=> "return from proc"<br>
            # "return from method"
          </strong>
          <br><br>
          Note: The previous fact about procs only seems to be true if the proc is
          created within the method that calls it as an error is called in other cases.
          This is not true for lambdas however.
          <br><br>
          <strong>
            var = Proc.new {return "return from proc"}<br>
            def test_proc(&block)<br>
            &#160;&#160;block.call<br>
            &#160;&#160;return "return from method"<br>
            end<br>
            puts test_proc(&var)<br>
            #=> error: unexpected return
            <br><br>
            var = lambda {return "return from lambda"}<br>
            def test_proc(&block)<br>
            &#160;&#160;block.call<br>
            &#160;&#160;return "return from method"<br>
            end<br>
            puts test_proc(&var)<br>
            #=> "return from method"
          </strong>
          <br><br>
          (Sources:
          <br>
          <a href="https://www.codecademy.com/en/courses/ruby-beginner-en-L3ZCI/1/5?curriculum_id=5059f8619189a5000201fbcb">
            codecademy: Blocks, Procs, and Lambdas
          </a>
          )
        </p>
      </div>
    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="method-response" class="title-anchor"></div>
      <h2 class="section-header">Method Response</h2>

      <div class="section-content">
        <p class="section-text-normal">
          <strong>
            puts [1,2,3].respond_to?(:push)<br>
            #=> true
            <br><br>
            puts "hello".respond_to?(:length)<br>
            #=> true
            <br><br>
            puts "hello".respond_to?(:each)<br>
            #=> false
            <br><br>
            puts ["cat","dog"].respond_to?(:times)
            #=> false
            <br><br>
          </strong>
          The respond_to? method returns true if the object that calls it is able to run the method
          given as a parameter.
          <br><br>
          (Sources:
          <br>
          <a href="https://www.codecademy.com/en/courses/ruby-beginner-en-L3ZCI/1/5?curriculum_id=5059f8619189a5000201fbcb">
            codecademy: The Zen of Ruby
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="native-sort" class="title-anchor"></div>
      <h2 class="section-header">Native Sort</h2>

      <div class="section-content">
        <p class="section-text-normal">
          When called the sort method will order values from low to high.
          <br><br>
          <strong>
            x = [2,5,3,1,6,7,4]<br>
            y = x.sort<br>
            p y<br>
            #=> [1,2,3,4,5,6,7]
            <br><br>
            x = [2,5,3,1,6,7,4]<br>
            x.sort!<br>
            p x<br>
            #=> [1,2,3,4,5,6,7]
            <br><br>
            x = ["x","c","m"]<br>
            x.sort!<br>
            p x<br>
            #=> ["c","m","x"]
            <br><br>
            x = ["cc","cb","caa","ca"]<br>
            x.sort!<br>
            p x<br>
            #=> ["ca","caa","cb","cc"]
          </strong>
          <br><br>
          By providing the sort method with a block it is possible to control the sorted order
          and what details about the variables are sorted.
          <br><br>
          <strong>
            x = [2,5,3,1,6,7,4]<br>
            x.sort! { |left, right| right &#60;=&#62; left }<br>
            p x<br>
            #=> [7,6,5,4,3,2,1]
            <br><br>
            x = ["giraffe", "cat", "mouse"]<br>
            x.sort! { |left, right| left.length &#60;=&#62; right.length }<br>
            p x<br>
            #=> ["cat", "mouse", "giraffe"]
          </strong>
          <br><br>
          The sort algorithm implemented by ruby is a quicksort and has been shown to be fast
          when compared to other sorting algorithms. It is a highly optimized piece of code and should be
          used.
          <br><br>
          (Sources:
          <br>
          <a href="https://www.dotnetperls.com/sort-ruby">
            dotnetperls: sort
          </a>
          <br>
          <a href="https://www.igvita.com/2009/03/26/ruby-algorithms-sorting-trie-heaps/">
            Ruby Algorithms: Sorting, Trie & Heaps
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="variable-arguments-splat" class="title-anchor"></div>
      <h2 class="section-header">Variable Arguments: Splat</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Variable arguments (or splat arguments as they are known in ruby) allow methods to accept any number
          (zero - max array length) of objects as parameters. The variables will be grouped into an array to be
          used by the method.
          <br><br>
          <strong>
            def lots_of_params(*splat)<br>
            &#160;&#160;splat.each { |var| puts "#{var}" }<br>
            end
          </strong>
          <br><br>
          Other parameters can be included along side the splat, though multiple splat arguments cannot be
          used.
          <br><br>
          <strong>
            def lots_of_params(word, *splat)<br>
            &#160;&#160;splat.each { |var| puts "#{word} #{var}" }<br>
            end
            <br><br>
            def lots_of_params(word, *splat, word2)<br>
            &#160;&#160;splat.each { |var| puts "#{word} #{var} #{word2}" }<br>
            end
          </strong>
          <br><br>
          (Sources:
          <br>
          <a href="https://www.codecademy.com/en/courses/ruby-beginner-en-ET4bU/1/2?curriculum_id=5059f8619189a5000201fbcb">
            codecademy: Methods, Blocks, &#38; Sorting
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="symbols" class="title-anchor"></div>
      <h2 class="section-header">Symbols</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Symbols are abstract references represented by a short string that follows a colon.
          They act as constants and can be referenced using variables.
          <br><br>
          <strong>
            :cat :dog :mouse :bear
            <br><br>
            x = :cat
          </strong>
          <br><br>
          Strings can be converted into symbols while a program is running by calling the method
          to_sym or intern on any string.
          <br><br>
          <strong>
            "cat".to_sym<br>
            "cat".intern
          </strong>
          <br><br>
          Symbols can be useful way to save time and memory space. Using symbols within
          a loop rather than a string literal stops the creation of multiple unneeded strings and when
          comparisons are been made symbols takes less time than strings.
          <br><br>
          However symbols are never garbage collected and so the memory is never released. Due to this
          symbols should never be created if they are to be used infrequently.
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional
          <br>
            <a href="http://alwayscoding.ca/momentos/2010/12/04/the-ruby-symbol-is-a-memory-leak/">
              The Ruby Symbol is a Memory Leak
            </a>
            <br>
            <a href="http://marcricblog.blogspot.co.uk/2010/02/ruby-symbols-ultimate-guide.html">
              Ruby Symbols Ultimate Guide
            </a>
            <br>
            <a href="https://www.codecademy.com/en/courses/ruby-beginner-en-Qn7Qw/1/4?curriculum_id=5059f8619189a5000201fbcb">
              Codecademy: Hashes and Symbols
            </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="custom-code-blocks" class="title-anchor"></div>
      <h2 class="section-header">Custom Methods That Use Code blocks</h2>

      <div class="section-content">
        <p class="section-text-normal">
          When making a method it is possible to instruct the method to accept and make
          use of code blocks by including one as a parameter. The parameter that signifies
          the code block must be the last parameter entered and start with a & symbol.<br>
          (Note: All occurrences of { } and "do end" are interchangeable. Also &code_block can
          be replaced by any legal name eg. &bacon)
          <br><br>
          <strong>
            def my_method(&code_block)<br>
            &#160;&#160; [1,2,3,4,5].each{|num| code_block.call(num)}<br>
            end
            <br><br>
            my_method() {|val| print "#{val} "}
            <br><br>
            #=> 1 2 3 4 5
            <br><br>
            def my_method(array, &code_block)<br>
            &#160;&#160; array.each do |num|<br>
            &#160;&#160;&#160;&#160; code_block.call(num)<br>
            &#160;&#160;end<br>
            end
            <br><br>
            my_method([1,2,3,4,5]) do |val|<br>
            &#160;&#160;print "#{val} "<br>
            end
            <br><br>
            #=> 1 2 3 4 5
          </strong>
          <br><br>
          The yield key term can be used in place of &#38;code_block which and does not require
          a given parameter.
          <br><br>
          <strong>
            def my_method(array)<br>
            &#160;&#160; array.each do |num|<br>
            &#160;&#160;&#160;&#160; yield(num)<br>
            &#160;&#160;end<br>
            end
            <br><br>
            my_method([1,2,3,4,5]) do |val|<br>
            &#160;&#160;print "#{val} "<br>
            end
            <br><br>
            #=> 1 2 3 4 5
          </strong>
          <br><br>
          <a href="../examples/enumerable.rb">More examples of use of blocks in code</a>
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional<br>
          <a href="https://www.codecademy.com/courses/ruby-beginner-en-L3ZCI/0/1?curriculum_id=5059f8619189a5000201fbcb">
            codeacademy: Blocks, Procs, and Lambdas
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="flow-control-summary" class="title-anchor"></div>
      <h2 class="section-header">Flow-Control: summary</h2>

      <div class="section-content">
        <p class="section-text-normal">
          For details on loops view <a href="#iterators">Loops & Iterators</a> and for
          details on code blocks view <a href="#custom-code-blocks">Custom Methods That Use Code
          blocks</a> and <a href="#custom-code-blocks">Procs & Lambdas</a>
          <br><br>
          Note: all parenthesis used in this sections are not required for
          code to work, just personal preference.
          <br><br>
          <u>If, else and unless</u>
          <br><br>
          <strong>
            if(true)<br>
            &#160;&#160;run code if true<br>
            else<br>
            &#160;&#160;run code if false<br>
            end<br>
            <br>
            unless(false)<br>
            &#160;&#160;run code if false<br>
            else<br>
            &#160;&#160;run code if true<br>
            end<br>
            <br>
            x = 5<br>
            if(x &#62; 5)<br>
              &#160;&#160;run code if x is greater than 5<br>
            elsif(x &#60; 5)<br>
              &#160;&#160;run code is x is less than 5<br>
            else<br>
              &#160;&#160;run code for all other cases<br>
            end
            <br><br>
            x = 5 if true<br>
            x = 5 unless false
          </strong>
          <br><br>
          <u>Ternary Operator</u>
          <br><br>
          <strong>
            x = true ? "one" : "two"<br>
            puts x<br>
            #=> one
            <br><br>
            x = false ? "one" : "two"<br>
            puts x<br>
            #=> two
          </strong>
          <br><br>
          <u>Case</u>
          <br><br>
          <strong>
            x = 6<br>
            case x<br>
            &#160;&#160;when 2<br>
            &#160;&#160;&#160;&#160;run code when x == 2<br>
            &#160;&#160;when 4<br>
            &#160;&#160;&#160;&#160;run code when x == 4<br>
            &#160;&#160;when 6<br>
            &#160;&#160;&#160;&#160;run code when x == 6<br>
            &#160;&#160;else<br>
            &#160;&#160;&#160;&#160;run code for all other cases<br>
            end
          </strong>
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional
          <a href="https://www.tutorialspoint.com/ruby/ruby_loops.htm">
            tutorialspoint
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="hashes" class="title-anchor"></div>
      <h2 class="section-header">Hashes</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Hashes are similar to array in that they hold multiple objects. The
          difference is that each object is assigned a key rather than an ordered
          position. Keys can be any object though strings and symbols are commonly used.
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse"}<br>
            x = {:pet_1 => "cat", :pet_2  => "dog", :pet_3  => "mouse"}
          </strong>
          <br><br>
          A new method of creating hashes with symbols as keys was added in Ruby 1.9, as shown below.
          This only works for symbols.
          <br><br>
          <strong>
            x = {pet_1: "cat", pet_2: "dog", pet_3: "mouse"}
          </strong>
          <br><br>
          New objects can be added by providing a new key.
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse",}<br>
            x["pet 4"] = "lion"
          </strong>
          <br><br>
          Each object is accessed and edited using it's own key.
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse"}<br>
            puts x["pet 1"]<br>
            x["pet 1"] = "tiger"<br>
            puts x["pet 1"]<br>
            #=> cat<br>
            # tiger
          </strong>
          <br><br>
          Attempting to access a key that does not exist will return nil. Unless when the
          hash was initialised you provided a parameter. In this case the given parameter would
          be returned.
          <br><br>
          <strong>
            x = {}<br>
            p x[:bacon]<br>
            #=> nil
            <br><br>
            x = Hash.new("no value")<br>
            puts x[:bacon]<br>
            #=> no value
            <br><br>
            x = Hash.new(0)<br>
            puts x[:bacon]<br>
            #=> 0
          </strong>
          <br><br>
          A Hashes length is found by using the methods length or size.
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse"}<br>
            puts "#{x.length} #{x.size}"<br>
            #=> 3  3
          </strong>
          <br><br>
          An array of the keys or values can be aquired using the methods 'keys'
          and 'values'
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse"}<br>
            puts x.keys<br>
            puts x.values<br>
            #=> ["pet 1", "pet 2", "pet 3"]<br>
            #["cat", "dog", "mouse"]
          </strong>
          <br><br>
          Hashes are iterated over using the each method. As of ruby 1.9 the iteration
          order will match the order in which values were added to the hash.
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse"}<br>
            x.each {|key, value| puts "#{key}: #{value}"}
          </strong>
          <br><br>
          Objects stored in hashes can be deleted with the method delete.
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse"}<br>
            x.delete("pet 1")
          </strong>
          <br><br>
          delete_if also deletes objects but only if the provided block equates to true.
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse"}<br>
            x.delete_if {|key, value| value == "cat"}
          </strong>
          <br><br>
          Hashes can be iterated over using the each_key and each_value methods
          as well.
          <br><br>
          <strong>
            x = {"pet 1" => "cat", "pet 2" => "dog", "pet 3" => "mouse"}
            <br><br>
            x.each_key { |key| print "#{key} "}<br>
            #>= pet 1 pet 2 pet 3
            <br><br>
            x.each_value { |value| print "#{value} "}<br>
            #>= cat dog mouse
          </strong>
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional<br>
          <a href="https://www.codecademy.com/en/courses/ruby-beginner-en-Qn7Qw/2/4?curriculum_id=5059f8619189a5000201fbcb">
            codeacademy: Hashes and Symbols
          </a>
          )
        </p>
      </div>
    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="arrays" class="title-anchor"></div>
      <h2 class="section-header">Arrays</h2>

      <div class="section-content">
        <p class="section-text-normal">
          Arrays can be instantiated either empty or with values. Each variable in
          an array can hold any type of object.
          <br><br>
          <strong>
            x = []<br>
            y = [1,2,3,4,5]<br>
            z = [1, "two", 3, "four", 5]
          </strong>
          <br><br>
          Array variables can be accessed in a number of ways as shown below.
          <br><br>
          <strong>
            y = [1,2,3,4,5]<br>
            puts y[0]<br>
            puts y[4]<br>
            puts y[-1]<br>
            puts y[-5]<br>
            #=> 1<br>
            # 5<br>
            # 5<br>
            # 1
          </strong>
          <br><br>
          Attempting to access an array element that does not exist will not
          throw a warning / exception but will only return nil.
          <br><br>
          <strong>
            y = [1,2,3,4,5]<br>
            p y[5]<br>
            #=> nil
          </strong>
          <br><br>
          New values can be pushed onto the end of the array in two ways.<br>
          This will increase the array length by 1.
          <br><br>
          <strong>
            x = []<br>
            x &#60;&#60; "value"<br>
            x.push("value")<br>
            p x<br>
            #=> ["value", "value"]
          </strong>
          <br><br>
          It is possible to add values to the start of the array using the
          upshift method.
          <br><br>
          <strong>
            x = [2,3,4,5]<br>
            x.unshift(1)<br>
            p x<br>
            #=> [1,2,3,4,5]
          </strong>
          <br><br>
          The method pop is used to remove the last element.<br>
          This will reduce the array length by 1. The removed value will be
          returned.
          <br><br>
          <strong>
            y = [1,2,3,4,5]<br>
            puts y.pop<br>
            p y<br>
            #=> 5<br>
            # [1,2,3,4]
          </strong>
          <br><br>
          Values at any position can be deleted from an array using the method
          delete_at(index). This will also return the deleted value.
          <br><br>
          <strong>
            y = [1,2,3,4,5]<br>
            p y.delete_at(2)<br>
            p y<br>
            #=> 3<br>
            # [1,2,4,5]
          </strong>
          <br><br>
          The method empty? will return a boolean value. True if the array holds
          no values.<br>
          The methods length and size will return the number of values held by
          the array.
          <br><br>
          <strong>
            y = []<br>
            puts y.empty?<br>
            puts "#{y.length} #{y.size}"<br>
            #=> true<br>
            # 0 0
          </strong>
          <br><br>
          The method include? returns true if the given parameter is held within the array.
          <br><br>
          <strong>
            y = [1,2,3]<br>
            puts y.include?(2)<br>
            #=> true
          <br><br>
            y = ["cat", "dog", "mouse"]<br>
            puts y.include?("dog")<br>
            #=> true
          </strong>
          <br><br>
          The method join combines all the values of the array into a single string.
          The characters you wish to be between each variable can be given as a parameter.
          <br><br>
          <strong>
            x = [1,2,3,4,5]<br>
            y = x.join<br>
            z = x.join(", ")<br>
            puts y<br>
            puts z<br>
            #=> "1234"<br>
            # "1, 2, 3, 4"
          </strong>
          <br><br>
          Arrays can added together, which simply connects the two together.
          <br><br>
          <strong>
            x = ["a","b","c"]<br>
            y = [1,2,3,4,5]<br>
            p x + y<br>
            #=> ["a","b","c",1,2,3,4,5]
          </strong>
          <br><br>
          Arrays can also be subtracted. The result of this is the removal of any values from the first array
          that occur in both array.
          <br><br>
          <strong>
            x = [1,2,3,4,5]<br>
            y = [3,4,5]
            <br><br>
            p x - y<br>
            #=> [1,2]
            <br><br>
            p y - x<br>
            #=> []
          </strong>
          <br><br>
          The methods first and last can be used for easy access to the start and end of arrays.
          The methods accept one parameter that signifies how many variable to return.
          <br><br>
          <strong>
            x = [1,2,3,4,5]<br>
            p x.first<br>
            p x.first(2)<br>
            p x.last<br>
            p x.last(2)<br>
            #=> [1]<br>
            # [1,2]<br>
            # [5]<br>
            # [4,5]
          </strong>
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="regexr-in-ruby" class="title-anchor"></div>
      <h2 class="section-header">RegExr in Ruby</h2>

      <div class="section-content">
        <p class="section-text-normal">
          There are a few methods that can be used by strings with regexr as parameters. Some
          of these include:
          <br><br>
          <strong>
            sub<br>
            gsub<br>
            scan
          </strong>
          <br><br>
          (For information on the first two methods view the section <a href="#substitutions-in-strings">Substitutions in Strings</a>)<br>
          (For more detail into regular expressions see <a href="regexr.html">Helpful regular expressions</a>)
          <br><br>
          Forward slashes are used at the start and end of a regular expression and can be given as parameters in all three methods shown.
          <br><br>
          The scan method takes one parameter and iterates through the given string, looping for each match it finds.
          <br><br>
          <strong>
            "this is a test".scan(/\w\w/) {|letter| print "#{letter} "}<br>
            #=>th is is te st
          </strong>
          <br><br>
          If scan is used without a code block it can be used to return a
          substring from a string.
          <br><br>
          <strong>
            puts "String".scan(/r\w/)<br>
            #=> ri
          </strong>
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="substitutions-in-strings" class="title-anchor"></div>
      <h2 class="section-header">Substitutions in Strings</h2>

      <div class="section-content section-text-normal">
          <p>
            <b>
              puts "bacon and eggs".sub("bacon", "sausage")<br>
              #=> sausage and eggs
              <br><br>
              puts "this is a test".gsub("t", "")<br>
              #=> his is a es
            </b>
          </p>
          <p>
            sub finds the first string which matches its first parameters and substitutes it for
            the seconds parameter.<br>
            gsub finds all instances of the first parameter and subs all of them for the seconds
            parameter
          </p>

          <p>The first parameter of these methods can be regular expressions</p>

          <p>
            Another method to substitute sections of strings is shown below.
            This works the same way a sub and can accept either a string or a
            regular expression as input.
          </p>

          <p>
            <b>
              x = "bacon and eggs"<br>
              x["eggs"] = "sausage"<br>
              puts x<br>
              #=> bacon and sausage
            </b>
          </p>

          <p>
            <b>
              x = "1 2 3 4 5"<br>
              x[/\d/] = "bacon"<br>
              puts x<br>
              #=> bacon 2 3 4 5
            </b>
          </p>

          <p>
            (Sources:<br>
             Beginning Ruby: From Novice to Professional<br>
             <a href="http://tryruby.org/levels/3/challenges/2">
               Codeschool: Challenge 2
             </a>
            )
          </p>
        <p><em>Updated: 08/05/2017</em></p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="interpolation" class="title-anchor"></div>
      <h2 class="section-header">Interpolation</h2>

      <div class="section-content">
        <p class="section-text-normal">
          <strong>
            x = "interpolation"<br>
            puts "This is #{x}"<br>
            #=> This is interpolation
            <br><br>
            i = 5<br>
            j = 10<br>
            puts "#{i} + #{j} = #{i + j}"<br>
            #=> 5 + 10 = 15
          </strong>
          <br><br>
          Interpolations is the insertion of the result from an expression directly into a string literal.
          Double quotes ( "string" instead of 'string' ) must be used in order for interpolation to work correctly.
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional
          )
        </p>
      </div>
    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="string-numerical-values" class="title-anchor"></div>
      <h2 class="section-header">String numerical values</h2>

      <div class="section-content">
        <p class="section-text-normal">
          <strong>
            "x".ord()<br>
            120.chr()
          </strong>
          <br><br>
          The method ord will return the ASCII value of the given sting. If the string has multiple
          characters the returned value will be of the first character in the string.
          <br><br>
          The method chr will return the character which is represented by the given number.
          This method can also accept a parameter so that different encodings might be used.
          <br><br>
          <strong>
            120.char(Encoding::UTF_8)<br>
            Encoding.name_list<br>
            #=> ["ASCII-8BIT", "UTF-8", "US-ASCII", "UTF-16BE", "UTF-16LE", "UTF-32BE", "UTF-32LE", "UTF-16", "UTF-32", ...]
          </strong>
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional<br>
          <a href="http://stackoverflow.com/questions/37820888/trying-to-understand-the-ruby-chr-and-ord-methods">
            stackoverflow: Trying to understand the Ruby .chr and .ord methods)
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="multi-line-strings" class="title-anchor"></div>
      <h2 class="section-header">Multi-line Strings</h2>

      <div class="section-content">
        <p class="section-text-normal">
          <strong>
            puts "This is text \nthat outputs on \nmultiple lines"
          </strong>
          <br><br>
          Using the new line character allows the creation of mulit line strings
          <br><br>
          <strong>
            puts %q{This is text<br>
              that outputs on<br>
              multiple lines}
          </strong>
          <br><br>
          This example multiple lines enables the creation of multi-line strings which do not require
          additional characters and simply mimics the layout as it is written in the code.
          The curly brackets may be replaced with any two delimiters (eg. ( ) &#60; &#62; ! !).
          <br><br>
          <strong>
            puts &#60;&#60;MY_STRING<br>
              This is text<br>
              that outputs on<br>
              multiple lines<br>
              MY_STRING
          </strong>
          <br><br>
          Using characters as a delimiter is possible as shown in this example. This is called a here document.
          (Note: had issues with indentation using this method. It seems as if it does not work unless
          no indentation is used on the end delimiter. Other methods produce more readable code)
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="constants" class="title-anchor"></div>
      <h2 class="section-header">Constants / Final Variables</h2>

      <div class="section-content">
        <p class="section-text-normal">
          To define a constant in Ruby create the variable with a capital as the first character
          <br><br>
          <strong>Dogs = 50</strong>
          <br><br>
          Any attempts to change the variable Dogs will result in a warning
          <br><br>
          Constant may only be defined outside of a method. They can be defined
          within a class or module (only the class / module will have
          access to the value) or they can be defined outside of classes and
          modules, which would make their scope global.
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional<br>
           <a href="https://www.tutorialspoint.com/ruby/ruby_variables.htm">
             tutorialspoint: Ruby Variables, Constants and Literals
           </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="iterators" class="title-anchor"></div>
      <h2  class="section-header">Loops and Iterators</h2>

      <div class="section-content">


          <p class="section-text-normal">
            A number of the methods here belong to the Enumerable module. A full list of the
            iterative methods offered by this module can be found here.
            <a href = "../examples/enumerable.pdf">pdf file</a>
            <a href = "http://ruby-doc.org/core-2.4.0/Enumerable.html">web site</a>
          </p>

        <h3><u>loop</u></h3>
        <p class="section-text-normal">
          Loop is the a basic loop and ends when a keyword used to stop
           loops is called (break / break if).
          true.
          <br><br>
          <strong>
            x = 0<br>
            loop {<br>
            &#160;&#160;x += 1<br>
            &#160;&#160;break<br>
          }
          <br><br>
            x = 0<br>
            loop {<br>
            &#160;&#160;x += 1<br>
            &#160;&#160;break if x >= 5<br>
          }
          </strong>
        </p>

        <h3><u>next, redo &#38; break if</u></h3>
        <p class="section-text-normal">
          The next key word can be used in loops and iterators to skip the
          remaining code and start the next loop / iteration.<br>
          The redo keyword is used in the same way as next but rather than
          continuing onto the next loop / iteration it restarts the previous.<br>
          The break if key word can be used to set a condition, which if met
          ends to loop / iteration.
          <br><br>
          <strong>
            x = 0<br>
            loop {<br>
            &#160;&#160;x += 1<br>
            &#160;&#160;if(x == 2)<br>
            &#160;&#160;&#160;&#160;next<br>
            &#160;&#160;end<br>
            &#160;&#160;if(x == 4)<br>
            &#160;&#160;&#160;&#160;redo<br>
            &#160;&#160;end<br>
            &#160;&#160;print "#{x} "<br>
            &#160;&#160;break if x &#62;= 5<br>
          }<br>
          #>= 1 3 5
          </strong>
        </p>

        <h3><u>while / until loops</u></h3>
        <p class="section-text-normal">
          The while loop runs while its given condition is true. The until loop runs until the
          given condition is true.
          <br><br>
          <strong>
            x = 0<br>
            while(x &#60; 100)<br>
            &#160;&#160;#repeat code while x is less than 100<br>
            &#160;&#160;x += 1<br>
            end
            <br><br>
            x = 0<br>
            until(x &#62; 100)<br>
            &#160;&#160;#repeat code until x is greater than 100<br>
            &#160;&#160;x += 1<br>
            end
          </strong>
        </p>

        <h3><u>for loop</u></h3>
        <p class="section-text-normal">
          The for loop runs the given number of times inclusively.
          <br><br>
          <strong>
            for i in 0..100<br>
            &#160;&#160;puts "#{i}: hello"<br>
            end
          </strong>
        </p>

        <h3><u>times</u></h3>
        <p class="section-text-normal">
          The method times runs the code in the provided block the specified number of times.
          The example will iterate through numbers 0 - 4 and run the code in the given block.
          <br><br>
          <strong>
          5.times do |number| puts "#{number}: Hello\n" end<br>
          5.times { |number| puts "#{number}: Hello" }
          </strong>
          <br><br>
          This method is used by objects holding integer values
        </p>

        <h3><u>upto / downto</u></h3>
        <p class="section-text-normal">
          The methods upto and downto iterate through the given numbers inclusively and run the code
          in the given block on each loop.
          <br><br>
          <strong>
            1.upto(5) do |number| puts "#{number}: Hello" end<br>
            1.upto(5) { |number| puts "#{number}: Hello" } <br>
            10.downto(5) do |number| puts "#{number}: Hello" end<br>
            10.downto(5) { |number| puts "#{number}: Hello" }
            "A".upto("Z") { |letter| puts letter }
          </strong>
        </p>

        <h3><u>step</u></h3>
        <p class="section-text-normal">
          The method step will iterate through the given numbers inclusively, in steps equals to the second parameter, and run the code
          in the given block on each loop. In the third example the final number will be 48 as the next value is greater than 50.
          <br><br>
          <strong>
            0.step(50, 5) {|number| puts "#{number}: Hello" }<br>
            0.step(50, 0.5) { |number| puts "#{number}: Hello" }<br>
            3.step(50, 5) { |number| puts "#{number}: Hello" }
          </strong>
          <br><br>
          This method is used by objects holding integer or float values.
        </p>

        <h3><u>each</u></h3>
        <p class="section-text-normal">
          The method each will loop through each object held in the given collection
          <br><br>
          <strong>
            (1..5).each do |number| puts "#{number}: Hello" end<br>
            (1..5).each { |number| puts "#{number}: Hello" }
          </strong>
          <br><br>
          Method is used by collections (array, hash, set, range).
        </p>

        <h3><u>each_with_index</u></h3>
        <p class="section-text-normal">
          The method each_with_index is the equivalent of each but provides the index as well. The index
          must be the second block variable.
          <br><br>
          <strong>
            (1..5).each_with_index { |number, index| puts "#{index}: #{number}" }
          </strong>
          <br><br>
          Method is used by collections (array, hash, set, range).
        </p>

        <h3><u>collect / map</u></h3>
        <p class="section-text-normal">
          The collect method returns a new array containing all the same variables but after
          they have been altered by the given code block.<br>
          The method map is used in the same way as collect and produces
          the same results.
          <br><br>
          <strong>
          p [1,2,3,4].collect {|number| number + 1 }<br>
          #=> [2,3,4,5]
          <br><br>
          p ["cat","mouse","dog"].collect {|string| string * 2 }<br>
          #=> ["catcat","mousemouse","dogdog"]
          </strong>
          <br><br>
          These methods are used by collections (array, hash, set, range).
        </p>

        <h3><u>select</u></h3>
        <p class="section-text-normal">
          The select method allows you to set a condition and returns an array containing only values that
          meet that criteria. If the block contains multiple lines of code the final line will act as the
          condition.
          <br><br>
          <strong>
            p [1,2,3,4,5,6,7,8].select { |num| num % 2 == 0}<br>
            #=> [2,4,6,8]
            <br><br>
            p [1,2,3,4,5,6,7,8].select { |num| <br>
              &#160;&#160;num % 2 == 0<br>
              &#160;&#160;num % 3 == 0<br>
            }<br>
            #=> [3,6]
          </strong>
        </p>

        <p class="section-text-normal">
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional<br>
          <a href="http://www.eriktrautman.com/posts/ruby-explained-map-select-and-other-enumerable-methods">
            Ruby Explained: Map, Select, and Other Enumerable Methods
          </a>
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="interesting-operators" class="title-anchor"></div>
      <h2 class="section-header">Interesting Operators</h2>

      <div class="section-content">
        <p class="section-text-normal">
          <b>x &#60;=&#62; y</b>: Returns 0 if x and y are equal, returns -1 if y
          is greater and 1 if x is greater.
          <br><br>
          <b>x ||= "cats"</b>: Assigns an object to the variable only if the variable currently
          holds a nil value.
          <br><br>
          <b>2**3</b>: Double asterick is will return the first number to the
          power of the second. The result of the example will be 8 (2*2*2).
          <br></br>
          (Sources:<br>
           Beginning Ruby: From Novice to Professional<br>
          <a href="https://www.codecademy.com/en/courses/ruby-beginner-en-1o8Mb/1/1?curriculum_id=5059f8619189a5000201fbcb">
            The Zen of Ruby
          </a>
          )
        </p>
        <p><em>Updated: 07/05/2017</em></p>
      </div>

    </div>

    <div class="divider"></div>

    <div class="section">

      <div id="output-to-console" class="title-anchor"></div>
      <h2 class="section-header">Output to Console </h2>

      <div class="section-content">
        <p class="section-text-normal">
          <strong>print</strong>: print a string to the console.
          <br><br>
          <strong>puts</strong>: print a string to the console with a new line after.
          <br><br>
          <strong>p</strong>: (Same as calling "string".inspect) Prints to screen in the same way as puts and returns the given value
          but values will be printed as they are in code.
          <strong>
            <br><br>
            p "hello"<br>
            #=> "hello"
            <br><br>
            p [1,2,3]<br>
            #=> [1,2,3]
            <br><br>
            p ["a", "b", "c"]<br>
            #=> ["a", "b", "c"]
          </strong>
          <br><br>
          (Sources:
          <br>
           Beginning Ruby: From Novice to Professional
          )
        </p>
      </div>

    </div>

    <div class="divider"></div>

  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js" rel="javascript"></script>
  <script src="../j-script/contents-arrays/contents-item.js" rel="javascript"></script>
  <script src="../j-script/contents-arrays/ruby-contents.js" rel="javascript"></script>
  <script src="../j-script/manage-contents.js" rel="javascript"></script>
  <script src="../j-script/contents-arrays/contents-search.js" rel="javascript"></script>
  <script src="../j-script/header.js" rel="javascript"></script>
  <script src="../j-script/summary-layout-switcher.js" rel="javascript"></script>
  <script src="../j-script/summary-pages-events.js" rel="javascript"></script>
</body>

</html>
